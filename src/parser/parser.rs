/*
 * The Parser.
 *
 * Create a AST based on input tokens generated by Lexer
 *
 *
 */
use std::iter::Peekable;

use super::lexer::{TokenType, Token, Lexer};
use crate::types::elements;

pub static CODE_STYLE:   u8   = 0b100;
pub static BOLD_STYLE:   u8   = 0b010;
pub static ITALIC_STYLE: u8   = 0b001;


struct Text {
    text: String,
    style: u8
}

struct Paragraph {
    texts: Vec<Text>,
}

impl Into<elements::Paragraph> for &Paragraph {
    fn into(self) -> elements::Paragraph {
        let mut para = elements::Paragraph::new();
        for text in &self.texts {
            let s = text.text.clone();
            let style = text.style;
            let text = elements::Text {text: s, style: style };
            para.texts.push(text);
        }
        return para;
    }
}

struct Heading {
    level: u8,
    text: Text,
}
impl Into<elements::Heading> for &Heading {
    fn into(self) -> elements::Heading {
        elements::Heading::new(self.text.text.clone(), self.level)
    }
}

struct Noop {}

pub trait AST {
    fn convert_to_renderable(&self) -> Box<dyn elements::Renderable>;
}

impl AST for Paragraph {
    fn convert_to_renderable(&self) -> Box<dyn elements::Renderable> {
        let text: elements::Paragraph = self.into();
        return Box::new(text);
    }
}
impl AST for Heading {
    fn convert_to_renderable(&self) -> Box<dyn elements::Renderable> {
        let heading: elements::Heading = self.into();
        return Box::new(heading);
    }
}
impl AST for Noop {
    fn convert_to_renderable(&self) -> Box<dyn elements::Renderable> {
        let blank = elements::Paragraph::new();
        return Box::new(blank);
    }
}

pub struct Exp {
    pub item: Box<dyn AST>,
}

pub struct Node {
    pub children: Vec<Exp>,
}

/*
 * The Parser struct
 * Contains the lexer from which it will generate the tree
 */
pub struct Parser {
    lexer: Lexer,
    tokens: Peekable<std::vec::IntoIter<Token>>,
    pub tree: Node,
}


impl Parser {
    pub fn new(lexer: Lexer) -> Self {
        let root = Node { children: vec![] };
        let input_lexer = lexer;
        let input_tokens = input_lexer.tokens.clone().into_iter().peekable();
        Parser { lexer: input_lexer, tokens: input_tokens, tree: root }
    }


    fn _asterisk_helper(&mut self) -> Text {
        let is_bold= self.tokens.peek().unwrap().token_type == TokenType::ASTERISK;
        let _tmp_token  = self.tokens.peek().unwrap().value.clone();
        // Move ahead of asterisk
        if is_bold {
            self.tokens.next();
        }
        let mut inner_text = self.text();

        // We are at least italics
        assert!(self.tokens.next().unwrap().token_type == TokenType::ASTERISK);
        let is_bold_after = self.tokens.peek().unwrap().token_type == TokenType::ASTERISK;
        if is_bold && is_bold_after {
            inner_text.style |= BOLD_STYLE;
            // Move over the asterisk
            self.tokens.next();
        } 
        // Meaning we have something like ** TEXT *
        else if is_bold && !is_bold_after {
            let _tmp: &str = &inner_text.text;
            inner_text.text = format!("{_tmp_token}{_tmp}");
            inner_text.style |= ITALIC_STYLE;
        }
        // We are italics otherwise
        else {
            inner_text.style |= ITALIC_STYLE;
        }

        return inner_text;
    }

    /* Parse a Text block
     * | TEXT | text TEXT | ASTERISK text ASTERISK | BACKTICK text BACKTICK
     */
    fn text(&mut self) -> Text {
        match &self.tokens.next() {
            Some(token) => {
                if token.token_type == TokenType::TEXT {
                    return Text { text: token.value.clone(), style: 0b000 }
                }
                // Bold or italic text
                else if token.token_type == TokenType::ASTERISK {
                    return self._asterisk_helper();
                }
                else if token.token_type == TokenType::BACKTICK {
                    let mut inner_text = self.text();
                    // It ends with a backtick 
                    assert!(self.tokens.next().unwrap().token_type == TokenType::BACKTICK);
                    inner_text.style |= CODE_STYLE;
                    return inner_text;
                }
                panic!("Invalid expression for text!");
            },
            None => { panic!("Invalid expression for text!") }
        }
    }

    /*
     * A collection of texts until a newline. It's essentially just a line, but 
     * calling it a paragraph alligns it with the HTML equivalent
     */
    fn paragraph(&mut self) -> Paragraph {
        let mut para = Paragraph { texts: vec![] };
        while self.tokens.peek().unwrap().token_type != TokenType::NEWLINE {
            let text = self.text();
            para.texts.push(text);
        }

        return para;
    }


    /* Parse a Heading
     * HASH heading | HASH paragraph 
     */
    fn heading(&mut self) -> Heading {
        let mut heading_size = 0;
        while self.tokens.peek().unwrap().token_type == TokenType::HASH {
            heading_size += 1;
            self.tokens.next();
        };
        let heading_text = self.text();
        return Heading { level: heading_size, text: heading_text }
    }

    /* exp
     * paragraph | heading
     */
    fn exp(&mut self) -> Exp {
        let token = self.tokens.peek();
        if token.is_none() {
            return Exp {item: Box::new(Noop{}) };
        }
        let token = token.unwrap().clone();
        println!("Got {:?}", token.token_type);
        if token.token_type == TokenType::TEXT 
        || token.token_type == TokenType::ASTERISK 
        || token.token_type == TokenType::BACKTICK
        {
            let tree = self.paragraph();
            return Exp { item: Box::new(tree) };
        }

        if token.token_type == TokenType::HASH {
            let tree = self.heading();
            return Exp { item: Box::new(tree) };
        }

        panic!("Invalid Exp type!")

    }

    /* Node
     * exp | exp NEWLINE node
     */
    fn node(&mut self) -> Node {
        let mut node = Node { children: vec![] };
        let exp = self.exp();
        node.children.push(exp);

        loop {
            match self.tokens.peek() {
                Some(token) => {
                if token.token_type == TokenType::NEWLINE { 
                    self.tokens.next();
                    continue
                } else {
                    node.children.push(self.exp());
                }
                },
                None => { break }
            }
        }
        return node;
    }

    // Entrypoint - we always begin with a node 
    pub fn parse(&mut self) {
        self.tree = self.node();
    }
}
